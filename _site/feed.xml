<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <description></description>
    <link>/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 09 Jul 2015 19:18:43 +0800</pubDate>
    <lastBuildDate>Thu, 09 Jul 2015 19:18:43 +0800</lastBuildDate>
    <generator>Jekyll v2.5.3</generator>
    
      <item>
        <title>Gotalk</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://github.com/rsms/gotalk&quot;&gt;Gotalk&lt;/a&gt; exists to make it easy for programs to &lt;em&gt;talk with one another over the internet&lt;/em&gt;, like a web app coordinating with a web server, or a bunch of programs dividing work amongst eachother.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/res/gotalk-comic.png&quot; alt=&quot;A terribly boring amateur comic strip&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Gotalk takes the natural approach of &lt;em&gt;bidirectional&lt;/em&gt; and &lt;em&gt;concurrent&lt;/em&gt; communication — any peer have the ability to expose “operations” as well as asking other peers to perform operations. The traditional restrictions of who can request and who can respond usually associated with a client-server model is nowhere to be found in gotalk.&lt;/p&gt;

&lt;h2 id=&quot;gotalk-in-a-nutshell&quot;&gt;Gotalk in a nutshell&lt;/h2&gt;

&lt;h4 id=&quot;bidirectional&quot;&gt;Bidirectional&lt;/h4&gt;

&lt;p&gt;There’s no discrimination on capabilities depending on who connected or who accepted. Both “servers” and “clients” can expose operations as well as send requests to the other side.&lt;/p&gt;

&lt;h4 id=&quot;concurrent&quot;&gt;Concurrent&lt;/h4&gt;

&lt;p&gt;Requests, results, and notifications all share a single connection without blocking eachother by means of &lt;a href=&quot;http://en.wikipedia.org/wiki/Protocol_pipelining&quot;&gt;&lt;em&gt;pipelining&lt;/em&gt;&lt;/a&gt;. There’s no serialization on request-result or even for a single large message, as the gotalk protocol is frame-based and multiplexes messages over a single connection. This means you can perform several requests at once without having to think about queueing or blocking.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/res/gotalk-pipeline-diagram.png&quot; alt=&quot;Diagram of how Gotalk uses connection pipelining&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;simple&quot;&gt;Simple&lt;/h4&gt;

&lt;p&gt;Gotalk has a simple and opinionated API with very few components. You expose an operation via “handle” and send requests via “request”.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;go
Handle(&quot;greet&quot;, func(params In) (Out, error) { ... })
// ...
Request(&quot;greet&quot;, params, &amp;amp;result)
&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;practical&quot;&gt;Practical&lt;/h4&gt;

&lt;p&gt;Gotalk includes a &lt;a href=&quot;https://github.com/rsms/gotalk/tree/master/js&quot;&gt;JavaScript implementation&lt;/a&gt; for Web Sockets alongside the full-featured Go implementation, making it easy to build modern web applications. The Gotalk source code also includes &lt;a href=&quot;https://github.com/rsms/gotalk/tree/master/examples&quot;&gt;a number of easily-readable examples&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;js
handle(&quot;greet&quot;, function (params, result) { ... });
// ...
request(&quot;greet&quot;, params, function (err, result) { ... });
&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;debuggable&quot;&gt;Debuggable&lt;/h4&gt;

&lt;p&gt;The Gotalk protocol’s wire format is byte based for easy on-the-wire inspection of data. It can thus be operated over any reliable byte transport. For example, here’s a protocol message representing a request for an operation “hello” with the parameter “world”:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;r001005hello00000005world
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;by-example&quot;&gt;By example&lt;/h2&gt;

&lt;p&gt;As just mentioned earlier, there are a few examples in the &lt;code&gt;examples&lt;/code&gt; directory demonstrating how you can use Gotalk. But let’s explore a simple program right here — a little something written in &lt;a href=&quot;http://golang.org/&quot;&gt;Go&lt;/a&gt; which demonstrates the use of an operation named “greet”:&lt;/p&gt;

&lt;p&gt;```go
func server() {
  gotalk.Handle(“greet”, func(in GreetIn) (GreetOut, error) {
    return GreetOut{“Hello “ + in.Name}, nil
  })
  if err := gotalk.Serve(“tcp”, “localhost:1234”); err != nil {
    log.Fatalln(err)
  }
}&lt;/p&gt;

&lt;p&gt;func client() {
  s, err := gotalk.Connect(“tcp”, “localhost:1234”)
  if err != nil {
    log.Fatalln(err)
  }
  greeting := &amp;amp;GreetOut{}
  if err := s.Request(“greet”, GreetIn{“Rasmus”}, greeting); err != nil {
    log.Fatalln(err)
  }
  log.Printf(“greeting: %+v\n”, greeting)
  s.Close()
}
```&lt;/p&gt;

&lt;p&gt;Let’s look at the above example in more detail, broken apart to see what’s going on.&lt;/p&gt;

&lt;p&gt;We begin by importing the gotalk library together with &lt;code&gt;log&lt;/code&gt; which we use for printing to the console:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;go
package main
import (
  &quot;log&quot;
  &quot;github.com/rsms/gotalk&quot;
)
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;We define two types: Expected input (request parameters) and output (result) for our “greet” operation:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;go
type GreetIn struct {
  Name string `json:&quot;name&quot;`
}
type GreetOut struct {
  Greeting string `json:&quot;greeting&quot;`
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Registers a process-global request handler for an operation called “greet” accepting parameters of type &lt;code&gt;GreetIn&lt;/code&gt;, returning results of type &lt;code&gt;GreetOut&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;go
func server() {
  gotalk.Handle(&quot;greet&quot;, func(in GreetIn) (GreetOut, error) {
    return GreetOut{&quot;Hello &quot; + in.Name}, nil
  })
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Finally at the bottom of our &lt;code&gt;server&lt;/code&gt; function we call &lt;code&gt;gotalk.Serve&lt;/code&gt;, which starts a local TCP server on port 1234:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;go
  if err := gotalk.Serve(&quot;tcp&quot;, &quot;localhost:1234&quot;); err != nil {
    log.Fatalln(err)
  }
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;In out &lt;code&gt;client&lt;/code&gt; function we start by connecting to the server:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;go
func client() {
  s, err := gotalk.Connect(&quot;tcp&quot;, &quot;localhost:1234&quot;)
  if err != nil {
    log.Fatalln(err)
  }
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Finally we send a request for “greet” and print the result:&lt;/p&gt;

&lt;p&gt;```go
  greeting := GreetOut{}
  if err := s.Request(“greet”, GreetIn{“Rasmus”}, &amp;amp;greeting); err != nil {
    log.Fatalln(err)
  }
  log.Printf(“greeting: %+v\n”, greeting)&lt;/p&gt;

&lt;p&gt;s.Close()
}
```&lt;/p&gt;

&lt;p&gt;Output:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;go
greeting: {Greeting:Hello Rasmus}
&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;gotalk-in-the-web-browser&quot;&gt;Gotalk in the web browser&lt;/h2&gt;

&lt;p&gt;Gotalk is implemented not only in the full-fledged Go package, but also in a &lt;a href=&quot;https://github.com/rsms/gotalk/tree/master/js&quot;&gt;JavaScript library&lt;/a&gt;. This allows writing web apps talking Gotalk via Web Sockets possible.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;go
// server.go:
package main
import (
  &quot;net/http&quot;
  &quot;github.com/rsms/gotalk&quot;
)
func main() {
  gotalk.HandleBufferRequest(&quot;echo&quot;, func(in []byte) ([]byte, error) {
    return in, nil
  })
  http.Handle(&quot;/gotalk&quot;, gotalk.WebSocketHandler(nil, nil))
  http.Handle(&quot;/&quot;, http.FileServer(http.Dir(&quot;.&quot;)))
  err := http.ListenAndServe(&quot;:1234&quot;, nil)
  if err != nil {
    panic(&quot;ListenAndServe: &quot; + err.Error())
  }
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;In our html document, we begin by registering any operations we can handle:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!-- index.html --&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;script type=&quot;text/javascript&quot; src=&quot;gotalk.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
gotalk.handle(&#39;greet&#39;, function (params, result) {
  result({ greeting: &#39;Hello &#39; + params.name });
});
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can’t “listen &amp;amp; accept” connections in a web browser, but we can “connect” so we do just that, connecting to “/gotalk” which is where we registered &lt;code&gt;gotalk.WebSocketHandler&lt;/code&gt; in our server.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!-- index.html --&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;script type=&quot;text/javascript&quot; src=&quot;gotalk.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
gotalk.handle(&#39;greet&#39;, function (params, result) {
  result({ greeting: &#39;Hello &#39; + params.name });
});

gotalk.connect(&#39;ws://&#39;+document.location.host+&#39;/gotalk&#39;, function (err, s) {
  if (err) return console.error(err);
  // s is a gotalk.Sock
});
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is enough for enabling the &lt;em&gt;server&lt;/em&gt; to do things in the &lt;em&gt;browser&lt;/em&gt; …&lt;/p&gt;

&lt;p&gt;But you probably want to have the &lt;em&gt;browser&lt;/em&gt; send requests to the &lt;em&gt;server&lt;/em&gt;, so let’s send a “echo” request just as our connection opens:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;js
gotalk.connect(&#39;ws://&#39;+document.location.host+&#39;/gotalk&#39;, function (err, s) {
  if (err) return console.error(err);
  s.request(&quot;echo&quot;, &quot;Hello world&quot;, function (err, result) {
    if (err) return console.error(&#39;echo failed:&#39;, err);
    console.log(&#39;echo result:&#39;, result);
  });
});
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;We could rewrite our code like this to allow some UI component to send a request:&lt;/p&gt;

&lt;p&gt;```js
var s = gotalk.connect(‘ws://’+document.location.host+’/gotalk’, function (err, s) {
  if (err) return console.error(err);
});&lt;/p&gt;

&lt;p&gt;button.addEventListener(‘click’, function () {
  s.request(“echo”, “Hello world”, function (err, result) {
    if (err) return console.error(‘echo failed:’, err);
    console.log(‘echo result:’, result);
  });
});
```&lt;/p&gt;

&lt;p&gt;The request will fail with an error “socket is closed” if the user clicks our button while the connection isn’t open.&lt;/p&gt;

&lt;p&gt;If you’re interested in learning more about using Gotalk with web browsers, check out &lt;a href=&quot;https://github.com/rsms/gotalk/tree/master/examples/websocket&quot;&gt;examples/websocket&lt;/a&gt; and &lt;a href=&quot;https://github.com/rsms/gotalk/tree/master/examples/websocket-chat&quot;&gt;examples/websocket-chat&lt;/a&gt; which shows how to use most of the Gotalk functionality to make interactive websites.&lt;/p&gt;

&lt;h2 id=&quot;protocol-and-wire-format&quot;&gt;Protocol and wire format&lt;/h2&gt;

&lt;p&gt;The wire format is designed to be human-readable and flexible; it’s byte-based and can be efficiently implemented in a number of environments ranging from HTTP and WebSocket in a web browser to raw TCP in Go or C. The protocol provides only a small set of operations on which more elaborate operations can be modeled by the user.&lt;/p&gt;

&lt;p&gt;Here’s a complete description of the protocol:&lt;/p&gt;

&lt;p&gt;```rb
conversation    = ProtocolVersion Message*
message         = SingleRequest | StreamRequest
                | SingleResult | StreamResult
                | ErrorResult&lt;/p&gt;

&lt;p&gt;ProtocolVersion = &lt;hexdigit&gt; &lt;hexdigit&gt;&lt;/hexdigit&gt;&lt;/hexdigit&gt;&lt;/p&gt;

&lt;p&gt;SingleRequest   = “r” requestID operation payload
StreamRequest   = “s” requestID operation payload StreamReqPart+
StreamReqPart   = “p” requestID payload
SingleResult    = “R” requestID payload
StreamResult    = “S” requestID payload StreamResult*
ErrorResult     = “E” requestID payload
Notification    = “n” type payload&lt;/p&gt;

&lt;p&gt;requestID       = &lt;byte&gt; &lt;byte&gt; &lt;byte&gt;&lt;/byte&gt;&lt;/byte&gt;&lt;/byte&gt;&lt;/p&gt;

&lt;p&gt;operation       = text3
type            = text3&lt;/p&gt;

&lt;p&gt;text3           = text3Size text3Value
text3Size       = hexUInt3
text3Value      = «byte&amp;gt;{text3Size} as utf8 text&amp;gt;&lt;/p&gt;

&lt;p&gt;payload         = payloadSize payloadData?
payloadSize     = hexUInt8
payloadData     = &lt;byte&gt;{payloadSize}&lt;/byte&gt;&lt;/p&gt;

&lt;p&gt;hexUInt3        = &lt;hexdigit&gt; &lt;hexdigit&gt; &lt;hexdigit&gt;
hexUInt8        = &lt;hexdigit&gt; &lt;hexdigit&gt; &lt;hexdigit&gt; &lt;hexdigit&gt;
                  &lt;hexdigit&gt; &lt;hexdigit&gt; &lt;hexdigit&gt; &lt;hexdigit&gt;
```&lt;/hexdigit&gt;&lt;/hexdigit&gt;&lt;/hexdigit&gt;&lt;/hexdigit&gt;&lt;/hexdigit&gt;&lt;/hexdigit&gt;&lt;/hexdigit&gt;&lt;/hexdigit&gt;&lt;/hexdigit&gt;&lt;/hexdigit&gt;&lt;/hexdigit&gt;&lt;/p&gt;

&lt;p&gt;A conversation begins with the protocol version:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;lua
00  -- ProtocolVersion 0
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;If the version of the protocol spoken by the other end is not supported by the reader, the connection is terminated and the conversation never starts. Otherwise, any messages are read and/or written.&lt;/p&gt;

&lt;p&gt;This is a “single-payload” request …&lt;/p&gt;

&lt;p&gt;&lt;code&gt;py
+----------------- SingleRequest
|  +---------------- requestID   &quot;001&quot;
|  |  +------------- text3Size   4
|  |  |   +--------- operation   &quot;echo&quot;
|  |  |   |       +- payloadSize 25
|  |  |   |       |
r001004echo00000019{&quot;message&quot;:&quot;Hello World&quot;}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;… and a corresponding “single-payload” result:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;py
+----------------- SingleResult
|  +---------------- requestID   &quot;001&quot;
|  |       +-------- payloadSize 25
|  |       |
R00100000019{&quot;message&quot;:&quot;Hello World&quot;}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Each request is identified by exactly three bytes—the &lt;code&gt;requestID&lt;/code&gt;—which is requestor-specific and has no purpose beyond identity, meaning the value is never interpreted.&lt;/p&gt;

&lt;p&gt;These “single” requests &amp;amp; results are the most common protocol messages, and as their names indicates, their payloads follow immediately after the header. For large payloads this can become an issue when dealing with many concurrent requests over a single connection, for which there’s a more complicated “streaming” request &amp;amp; result type which we will explore later on.&lt;/p&gt;

&lt;p&gt;If an error occurs while handing a request, an “error” is send as the reply instead of a regular result:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;py
+----------------- ErrorResult
|  +---------------- requestID   &quot;001&quot;
|  |       +-------- payloadSize 38
|  |       |
E00100000026{&quot;error&quot;:&quot;Unknown operation \&quot;echo\&quot;&quot;}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;As with all messages, what the payload data represents is up to each application and not part of the Gotalk protocol although we use JSON in our examples here.&lt;/p&gt;

&lt;p&gt;When there’s no expectation on a response, Gotalk provides a “notification” message type:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;py
+---------------------- Notification
|              +--------- type        &quot;chat message&quot;
|              |       +- payloadSize 50
|              |       |
n00cchat message00000032{&quot;message&quot;:&quot;Hi&quot;,&quot;from&quot;:&quot;nthn&quot;,&quot;chat_room&quot;:&quot;gonuts&quot;}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Notifications are never replied to nor can they cause “error” results.&lt;/p&gt;

&lt;p&gt;For more complicated scenarios there are “streaming-payload” requests and results at our disposal. This allows transmitting of large amounts of data without the need for large buffers. For example this could be used to forward audio data to audio playback hardware, or to transmit a large file off of slow media like a tape drive or hard-disk drive.&lt;/p&gt;

&lt;p&gt;Because transmitting a streaming request or result does not occupy “the line” (single-payloads are transmitted serially), they can also be useful when there are many concurrent requests happening over a single connection.&lt;/p&gt;

&lt;p&gt;Here’s an example of a “streaming-payload” request …&lt;/p&gt;

&lt;p&gt;```py
+—————– StreamRequest
|  +—————- requestID   “001”
|  |      +——— operation   “echo”
|  |      |       +- payloadSize 25
|  |      |       |
s001004echo0000000b{“message”:&lt;/p&gt;

&lt;p&gt;+—————– streamReqPart
|  +—————- requestID   “001”
|  |       +——– payloadSize 25
|  |       |
p0010000000e”Hello World”}&lt;/p&gt;

&lt;p&gt;+—————– streamReqPart
|  +—————- requestID   “001”
|  |       +——– payloadSize 0 (end of stream)
|  |       |
p00100000000
```&lt;/p&gt;

&lt;p&gt;… followed by a “streaming-payload” result:&lt;/p&gt;

&lt;p&gt;```py
+—————– StreamResult (1st part)
|  +—————- requestID   “001”
|  |       +——– payloadSize 25
|  |       |
S0010000000b{“message”:&lt;/p&gt;

&lt;p&gt;+—————– StreamResult (2nd part)
|  +—————- requestID   “001”
|  |       +——– payloadSize 25
|  |       |
S0010000000e”Hello World”}&lt;/p&gt;

&lt;p&gt;+—————– StreamResult
|  +—————- requestID   “001”
|  |       +——– payloadSize 0 (end of stream)
|  |       |
S00100000000
```&lt;/p&gt;

&lt;p&gt;Requests and results does not need to match on the “single” vs “streaming” detail — it’s perfectly fine to send a streaming request and read a single response, or send a single response just to receive a streaming result. &lt;em&gt;The payload type is orthogonal to the message type&lt;/em&gt;, with the exception of an error response which is always a “single-payload” message, carrying any information about the error in its payload. Note however that the current version of the Go package does not provide a high-level API for mixed-kind request-response handling.&lt;/p&gt;

&lt;h2 id=&quot;open-source-code&quot;&gt;Open source code&lt;/h2&gt;

&lt;p&gt;Gotalk is a hobby project and free to use, modify and even sell within the bounds of &lt;a href=&quot;https://github.com/rsms/gotalk#mit-license&quot;&gt;the liberal MIT-license&lt;/a&gt;. You’ll find the most recent version at &lt;a href=&quot;https://github.com/rsms/gotalk&quot;&gt;https://github.com/rsms/gotalk&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 21 Jan 2015 00:00:00 +0800</pubDate>
        <link>/2015/01/21/gotalk.html</link>
        <guid isPermaLink="true">/2015/01/21/gotalk.html</guid>
        
        
      </item>
    
      <item>
        <title>DBX 2013</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://farm8.staticflickr.com/7451/9254559408_e1026556da_k.jpg&quot; alt=&quot;&quot; /&gt;
Dropbox’s first developer conference &lt;em&gt;DBX&lt;/em&gt; was a lot of fun. Me and Adam Polselli gave a talk on &lt;em&gt;“Designing Products for People”&lt;/em&gt; as seen in one of the videos below.&lt;/p&gt;

&lt;iframe src=&quot;//player.vimeo.com/video/70089044&quot; width=&quot;600&quot; height=&quot;337&quot; frameborder=&quot;0&quot; webkitallowfullscreen=&quot;&quot; mozallowfullscreen=&quot;&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

&lt;iframe src=&quot;//player.vimeo.com/video/70663871&quot; width=&quot;600&quot; height=&quot;337&quot; frameborder=&quot;0&quot; webkitallowfullscreen=&quot;&quot; mozallowfullscreen=&quot;&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;img src=&quot;http://farm4.staticflickr.com/3745/9254556280_10cbcba539_k.jpg&quot; width=&quot;2048&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 09 Jul 2013 00:00:00 +0800</pubDate>
        <link>/2013/07/09/dbx2013.html</link>
        <guid isPermaLink="true">/2013/07/09/dbx2013.html</guid>
        
        
      </item>
    
      <item>
        <title>Hello, Dropbox</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://farm9.staticflickr.com/8225/8580803186_ccf9d4337b_o.png&quot; width=&quot;50%&quot; align=&quot;right&quot; /&gt;I’m very excited to let you know that I’m joining &lt;a href=&quot;https://www.dropbox.com/&quot;&gt;Dropbox&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;After two years at Facebook I couldn’t be more proud. Proud to have been part of something as important as Facebook and proud of the work I’ve done with shaping the future of mobile communication. It’s truly been a fantastic time of my life — an experience rich of great people, mind-boggling challenges and once-in-a-lifetime experiences.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Look at the past for inspiration, but focus on the future, because tomorrow is shaped by the choices we make today.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;At Dropbox I’m going to work hard to make all our lives better. Remove friction from technical details in our modern daily lives, and relieve us from worrying about our “stuff” — from quick snapshots and hasty notes to precious memories.&lt;/p&gt;

&lt;p&gt;This is going to be such a fun adventure.&lt;/p&gt;
</description>
        <pubDate>Thu, 21 Mar 2013 00:00:00 +0800</pubDate>
        <link>/career/2013/03/21/hello-dropbox.html</link>
        <guid isPermaLink="true">/career/2013/03/21/hello-dropbox.html</guid>
        
        <category>facebook,</category>
        
        <category>dropbox</category>
        
        
        <category>career</category>
        
      </item>
    
      <item>
        <title>The 1950s called and wanted their toolbox back</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://farm9.staticflickr.com/8358/8336375923_9f0dca4da9_o.png&quot; width=&quot;50%&quot; align=&quot;right&quot; /&gt;Your favourite fancy-pants modern programming language is from the 1950s.&lt;/p&gt;

&lt;p&gt;Pretty much any programming language used today is &lt;a href=&quot;http://www.levenez.com/lang/&quot;&gt;a derivative&lt;/a&gt; of &lt;a href=&quot;http://en.wikipedia.org/wiki/Fortran&quot;&gt;Fortran&lt;/a&gt; or &lt;a href=&quot;http://en.wikipedia.org/wiki/Lisp_%28programming_language%29&quot;&gt;Lisp&lt;/a&gt;, both born in the 1950s. Okay, reality check: It’s 2013—yes, 60 years later—and we have cars that drive themselves on the street, robots roaming the surface of alien planets and tiny networked devices with interactive surfaces that we keep in our pockets, which are orders of magnitude more powerful than the computers of the 1950s.&lt;/p&gt;

&lt;p&gt;This might come as a surprise to readers not into &lt;a href=&quot;http://en.wikipedia.org/wiki/Computer_programming&quot;&gt;computer programming&lt;/a&gt;, but professional and hobbyist programmers alike all &lt;strong&gt;&lt;em&gt;use the same tools as we did 60 years ago&lt;/em&gt;&lt;/strong&gt; — one-dimensional, sequential plain text. It’s like writing a single document in Word &lt;em&gt;without using any formatting&lt;/em&gt;, with the goal of instructing a large symphony orchestra to perform a complex musical piece. That app you’re using could as well have been built in the 1950s, had we the same powerful hardware back then. We are thoughtlessly using Grandpa’s old toolbox to build a spaceship.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;http://en.wikipedia.org/wiki/Computer_programming&quot;&gt;Wikipedia article on computer programming&lt;/a&gt; opens up with the following description:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Computer programming […] is the process of designing, writing, testing, debugging, and maintaining the source code of computer programs.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Interestingly “writing” is an inherent part of this canonical description of “computer programming” — a subject under constant scrutiny. Programming has become synonymous with “writing code”, which really tickles my LOL, so to speak.&lt;/p&gt;

&lt;h2 id=&quot;jumping-higher--beyond-the-written-text&quot;&gt;Jumping higher &amp;amp; beyond the written text&lt;/h2&gt;

&lt;p&gt;Writing is a universal tool we created for conveying information in a way that can be easily copied, shared and distributed. Although writing as a form of communication goes as far back as 5200 years (clay tablets used in Mesopotamia around 3200 BCE), we would not reach an interesting level of literacy until the &lt;a href=&quot;http://en.wikipedia.org/wiki/File:Illiteracy_france.png&quot;&gt;late 19th century&lt;/a&gt; when reading was no longer exclusive to monks, academics and the educated upper class, but became an extremely important tool of humanity, propelling us into the industrial age and beyond. As a species we are builders. In a way, we have taken control of our evolution not by changing our minds or physique, to become larger so we can build greater things, but by building a tower of knowledge that enables us to create small and large tools which in turn enables us to build houses taller than a hundred people and explore the surface of alien planets no human has ever set a foot on.&lt;/p&gt;

&lt;p&gt;Just as the now mundane tools pen and paper have evolved from blood and cave walls into sharp stones and clay tablets—into ink and papyrus into pen and paper and lately into stylus and screen—the fundamental tools (i.e. computer programming) we use today to build tomorrow’s toolbox (i.e. software) have not evolved to make use of our current arsenal of technology. How will we build software 20 years from now? 200 years from now? Hopefully not limited by the same factors as we are today, namely expressing multi-dimensional and naturally concurrent systems in one-dimensional, sequential text.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://farm9.staticflickr.com/8078/8337433556_d3104c8b59_o.png&quot; alt=&quot;High jump&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We seem to have reached an upper level of utility with our current toolbox for programming computers, much like the athletic Olympic sport of &lt;a href=&quot;http://en.wikipedia.org/wiki/High_jump&quot;&gt;High Jump&lt;/a&gt;, where the current record of 2.45m has remained for 20 years — here we have reached the limit of the tool box (the human body.) To allow High Jump to “progress” further, we would either need to change the definition and rules of the sport or allow modified human bodies (i.e. doping, cybernetics, etc) to participate.&lt;/p&gt;

&lt;p&gt;Our current toolbox for software creation has an inherent limitation at its very foundation: low bandwidth. One-dimensional, sequential text utilises only our sense of sight, and is interpreted by a small section of our brains, forming a “bridge” or “proxy” for meaning and expression.&lt;/p&gt;

&lt;p&gt;The high-level goal of computer programming is to enable the creation of highly customised tools: A video player app is a tool for playing specific kinds of moving pictures synchronised with audio. The game on your smartphone that you play on the bus is a tool for creating feelings of accomplishment. The system of a bank is a specialised tool that keeps track of who has what money.&lt;/p&gt;

&lt;h2 id=&quot;what-about-tomorrow&quot;&gt;What about tomorrow?&lt;/h2&gt;

&lt;p&gt;So how do we make full use of today’s technology to enable these very creative individuals known as computer programmers—or rather; software engineers—to jump even higher? I doubt a thousand year old one-dimensional tool like text is the answer, when we perform other tasks in life using tools which make better use of our senses — touch and hearing, and don’t forget the higher-level senses like image recognition and spatial ability. Our minds are truly powerful and very able.&lt;/p&gt;

&lt;p&gt;So it all comes down to &lt;a href=&quot;http://en.wikipedia.org/wiki/Human%E2%80%93computer_interaction&quot;&gt;Human-Computer Interaction&lt;/a&gt;, the field of interaction between people and computers. Programming is, in fact, just an interface &lt;em&gt;for&lt;/em&gt; humans &lt;em&gt;to control&lt;/em&gt; computers.&lt;/p&gt;

&lt;p&gt;A good example is the car. If you owned a car in the 1800s you would know how to maintain that car. You would know how the engine operated, and you would be able to diagnose and fix problems. Today you simply press a button to start or stop the car. Open up the engine compartment hood of a modern car and you will probably just see a large flat surface with a logotype on it — the heart of the car has become irrelevant knowledge for most car operators like yourself.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://farm9.staticflickr.com/8491/8336375797_bea36eb333_o.png&quot; width=&quot;30%&quot; align=&quot;right&quot; /&gt;The car of the 1800s would not be a very useful tool in today’s measures as it would likely break down during short trips, would not go very fast and was expensive to produce and operate. The car of today is an extremely able tool which extends your ability of transportation both in terms of time (speed), comfort, distance and freight. We have refined our tools (hammers and screwdrivers replaced by robotic specialised factories and lasers) by applying the process of interface abstraction to in order to make the human able to do more using less cognitive effort. They year of 2012 even brought us street-legal &lt;a href=&quot;http://newsfeed.time.com/2012/09/26/speeding-into-the-future-self-driving-cars-are-now-legal-in-california/&quot;&gt;cars which drives themselves&lt;/a&gt; — a step further in the progress of abstraction, enabling us not only to transport ourselves long distances in comfort, but also free up time for other tasks (i.e. while the car is driving.)&lt;/p&gt;

&lt;p&gt;The field of programming need to see a renaissance in fundamental reinvention, just as it did in the 1950s when programming machines using levers and buttons was replaced by programming machines using textual sequences of computer commands.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://farm9.staticflickr.com/8072/8337458910_786074443c_o.png&quot; alt=&quot;Minority report FTW&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Okay, maybe we’re not in the movie Minority Report just yet, but still, today’s multi-sensory input-output technology like high-density interactive &lt;a href=&quot;http://www.technologyreview.com/news/417879/touch-screens-that-touch-back/&quot;&gt;touch screens which “touches back”&lt;/a&gt; and &lt;a href=&quot;http://www.hitl.washington.edu/scivw/EVE/I.B.1.3DSoundSynthesis.html&quot;&gt;spatial 3D positional audio&lt;/a&gt; are all interesting technology that just now have become economically viable and high-fidelity enough to be forgotten — “forgotten” as in us no longer thinking about the technology itself, but to be able to intuitively focus on whatever is presented and conveyed.&lt;/p&gt;

&lt;h2 id=&quot;visions-for-the-future-from-the-past&quot;&gt;Visions for the future, from the past&lt;/h2&gt;

&lt;p&gt;In the rather profound &lt;a href=&quot;http://www.cs.virginia.edu/~evans/cs655/readings/smalltalk.html&quot;&gt;Design Principles Behind Smalltalk&lt;/a&gt; in which &lt;a href=&quot;http://en.wikipedia.org/wiki/Daniel_Henry_Holmes_Ingalls%2C_Jr.&quot;&gt;Daniel Ingalls&lt;/a&gt; of the Xerox PARC expresses the interesting ethos of enabling creative individuals to program computers, we can read the following:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;[…] a vision that includes a creative individual and the best computing hardware available.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Ingalls builds further on this vision, writing:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;If a system is to serve the creative spirit, it must be entirely comprehensible to a single individual.&lt;/p&gt;

  &lt;p&gt;The point here is that the human potential manifests itself in individuals. To realize this potential, we must provide a medium that can be mastered by a single individual. Any barrier that exists between the user and some part of the system will eventually be a barrier to creative expression.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Back in 1981 when the above document was published, human-computer hardware interfaces were far from as high fidelity as they are today. There were no low-latency touch screens you could hold in your hand and there were no graphics processors able to render complex movie scenes on-the fly. Keyboards were still the lowest friction and efficient way for a human to provide a computer with input. With today’s hi-fi user input hardware we should be able to further lower the friction—the “barrier”—between the human and the computer, and at the same time also increase the bandwidth of communication.&lt;/p&gt;

&lt;p&gt;As early as 1963 was alternative human-computer interaction hardware with potentially lower level of friction and higher bandwidth explored. Most notably is &lt;a href=&quot;http://en.wikipedia.org/wiki/Sketchpad&quot;&gt;Sketchpad&lt;/a&gt;, which used a stylus pen with an interactive screen, as likely being the most significant invention in the field of HCI.&lt;/p&gt;

&lt;p&gt;Below here is a video of &lt;a href=&quot;http://en.wikipedia.org/wiki/Alan_Kay&quot;&gt;Alan Kay&lt;/a&gt;’s famous talk &lt;a href=&quot;http://archive.org/details/AlanKeyD1987&quot;&gt;“Doing with Images Makes Symbols”&lt;/a&gt; from 1987 in which we see both Sketchpad and GrAIL (another early graphical programming environment from 1968) in action:&lt;/p&gt;

&lt;iframe src=&quot;http://archive.org/embed/AlanKeyD1987&quot; width=&quot;640&quot; height=&quot;480&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;
&lt;p&gt;&lt;br /&gt;
&lt;small&gt;&lt;em&gt;Sketchpad segment start at 04:00. GrAIL segment starts at at 24:10.&lt;/em&gt;&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;Not only was Sketchpad the first ever stylus input device, but also pioneered graphical windows and object-oriented programming. The computer it ran on was large enough to have it’s own roof and had a total memory of 460 kilobytes (a small photo from your smartphone is likely to be 2-4 times &lt;em&gt;larger&lt;/em&gt; that the entire memory of this machine), and the processor could perform 400 000  instructions per second. Your average smartphone today can perform around 4 000 000 000 instructions per second (per core) — that means that what’s in your pocket today is not only extremely small in comparison to the giant computer Sketchpad was running on in 1963, but is also 10 000 times more powerful.&lt;/p&gt;

&lt;p&gt;Now, remember the 1950s called and still haven’t got their programming toolbox back.&lt;/p&gt;
</description>
        <pubDate>Tue, 01 Jan 2013 00:00:00 +0800</pubDate>
        <link>/languages/2013/01/01/1950s-called-wanted-toolbox-back.html</link>
        <guid isPermaLink="true">/languages/2013/01/01/1950s-called-wanted-toolbox-back.html</guid>
        
        <category>programming</category>
        
        
        <category>languages</category>
        
      </item>
    
      <item>
        <title>Sol — a sunny little virtual machine</title>
        <description>&lt;p&gt;During this weekend, together with a few evenings earlier this week, I created a rather simple &lt;a href=&quot;http://en.wikipedia.org/wiki/Virtual_machine&quot;&gt;virtual machine&lt;/a&gt; dubbed &lt;a href=&quot;https://github.com/rsms/sol&quot;&gt;“Sol”&lt;/a&gt;, after the Swedish word for “sun”. I’ve read a lot about VM design and I’m into stuff like OS design, programming languages and other seeminlgy obscure and nerdy stuff surrounding the concept of a computer as a generic tool.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;A virtual machine (VM) is a software implementation of a machine (i.e. a computer) that executes programs like a physical machine. — &lt;a href=&quot;http://en.wikipedia.org/wiki/Virtual_machine&quot;&gt;Wikipedia&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/rsms/sol&quot;&gt;Sol&lt;/a&gt; is a process virtual machine that runs inside an operating system process. However, inside Sol there are multiple tasks (just like most operating systems have processes) and so for a program running in Sol it does not matter what the world looks like on the outside. We could even make Sol boot directly from hardware, but that would just be crazytown. Trust me. I’ve been down that road before.&lt;/p&gt;

&lt;p&gt;The purpose of Sol is learning. As we are defining our world, we have an extremely high degree of freedom. One major component of a virtual machine is the provided &lt;em&gt;instruction set&lt;/em&gt;. An &lt;em&gt;instruction&lt;/em&gt; is the simplest type of operation that a program can perform, and so the set of instructions provided by the virtual machine to programs running in it need to be universal and efficient.&lt;/p&gt;

&lt;h2 id=&quot;design-overview&quot;&gt;Design overview&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;http://farm9.staticflickr.com/8335/8089500428_b103d2c23d_o.png&quot; alt=&quot;Sketch of the VM with schedulers&quot; /&gt;&lt;/p&gt;

&lt;p&gt;In the Sol VM there are one or more &lt;em&gt;schedulers&lt;/em&gt;, each running on one CPU core (not yet implemented at the time of writing this).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://farm9.staticflickr.com/8049/8089500560_622bd30623_o.png&quot; alt=&quot;Sketch of a scheduler&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Each &lt;em&gt;scheduler&lt;/em&gt; maintains a list of &lt;em&gt;tasks&lt;/em&gt; to be run. This list is called the &lt;em&gt;run queue&lt;/em&gt;. A scheduler also maintains I/O watchers, timers, handles OS interrupts, etc. The scheduler does most of the work in Sol as it not only does all those fancy things I just described, but it also executes program code.&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;run queue&lt;/em&gt; is a list of tasks ordered in the way they are scheduled.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;The scheduler takes the first task in the list from the &lt;em&gt;run queue&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;executes the task (more on what that means later).&lt;/li&gt;
  &lt;li&gt;If the task ended with an “end” or “error” status, the task is removed from the run queue…&lt;/li&gt;
  &lt;li&gt;…otherwise places the task at the end of the list.&lt;/li&gt;
  &lt;li&gt;If there are any I/O watchers or timers, check timers for expiry and possibly call the host OS kernel to check on pending “asynchronous” I/O events.
    &lt;ol&gt;
      &lt;li&gt;If an event has happened, like a timer expired or fired, the correlating task is added to the run queue so that the task can read the event it is waiting for.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;The scheduler repeats this process (e.g. starting from point 1.) as long as there are any tasks in the run queue.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Let’s have a look at a &lt;em&gt;task&lt;/em&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://farm9.staticflickr.com/8195/8089499085_ddd9cb9de2_o.png&quot; alt=&quot;Sketch of a task and its activation records&quot; /&gt;&lt;/p&gt;

&lt;p&gt;As we can see, a &lt;em&gt;task&lt;/em&gt; is mostly an abstraction and contains only one significant component: &lt;a href=&quot;http://en.wikipedia.org/wiki/Call_stack#Structure&quot;&gt;&lt;em&gt;Activation records&lt;/em&gt;&lt;/a&gt;. These comprise a task’s call stack and each &lt;em&gt;activation record&lt;/em&gt; corresponds to one (active) function call. An activation record contains a reference to the function prototype (more on this in just a second) it’s executing, a &lt;em&gt;program counter&lt;/em&gt; (usually called &lt;em&gt;PC&lt;/em&gt;) which is a cursor for the currently executing program instruction and finally a registry for values.&lt;/p&gt;

&lt;p&gt;A &lt;strong&gt;&lt;em&gt;function prototype&lt;/em&gt;&lt;/strong&gt; is the constants and the instruction of a function, but without a context (or “function closure”) with local variables etc. A &lt;em&gt;function prototype&lt;/em&gt; is kind of like a building without any people or furniture. Albeit the name, it’s not really comparable to a blueprint as a &lt;em&gt;function prototype&lt;/em&gt; is not copied or implemented, but is actually used as-is.&lt;/p&gt;

&lt;p&gt;The &lt;strong&gt;&lt;em&gt;program counter&lt;/em&gt;&lt;/strong&gt; is simply a number that corresponds to an offset into the function prototype’s program (ordered list of instructions). As an activation record (we can think about this as a piece of running code) is executed, the &lt;em&gt;program counter&lt;/em&gt; (PC) is incremented as each instruction is executed. Sometimes the PC is decremented, when a program jumps backwards (e.g. when performing a loop). The PC plays a central role in an instruction-based program (like your computer or phone’s hardware which is most likely incrementing a PC right now).&lt;/p&gt;

&lt;p&gt;The &lt;strong&gt;&lt;em&gt;registry&lt;/em&gt;&lt;/strong&gt; is essentially a region of temporary memory that the executing program can use to store variable data. Imagine this simple function:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def foo(x, y):
  x = x * 5
  x = x * y
  return x
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here the program needs a way to store the value created by &lt;code&gt;x * 5&lt;/code&gt; that it can then pass to &lt;code&gt;x * y&lt;/code&gt; which also needs to store its resulting value somewhere before using it with &lt;code&gt;return&lt;/code&gt;. All local variables are stored in registers and thus access is very efficient. Something like this happens when executing the “foo” function (“R(x)” means “register x”):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;argument 0 and 1 are already in R(0) and R(1)
load constant &quot;5&quot; into R(2)
multiply value-of R(0) with value-of R(2), put the result in R(0)
multiply value-of R(0) with value-of R(1), put the result in R(0)
return R(0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sol is a register-based virtual machine. Operands and results are read and stored from and to numbered registers, rather than “pushed” and “popped” to and from a stack (as with &lt;em&gt;stack-based virtual machines&lt;/em&gt;). Register-based virtual machines avoid the push and pop operations usually surrounding other instructions, reducing code size, but in several cases also increases speed of execution (compared to stack-based virtual machines).&lt;/p&gt;

&lt;p&gt;In the most excellent paper &lt;a href=&quot;http://www.lua.org/doc/jucs05.pdf&quot;&gt;“The Implementation of Lua 5.0”&lt;/a&gt; Roberto, Luiz and Waldemar describes the (not really a) problem with code size and decoding overhead:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;There are two problems usually associated with register-based machines: code size and decoding overhead. An instruction in a register machine needs to specify its operands, and so it is typically larger than a corresponding instruction in a stack machine. (For instance, the size of an instruction in Lua’s virtual machine is four bytes, while the size of an instruction in several typical stack machines, including the ones previously used by Lua, is one or two bytes.) On the other hand, register machines generate less opcodes than stack machines, so the total code size is not much larger.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Sol takes a lot of inspiration from &lt;a href=&quot;http://www.lua.org/&quot;&gt;Lua&lt;/a&gt; as well as &lt;a href=&quot;http://www.erlang.org/&quot;&gt;Erlang&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;instructions-and-operations&quot;&gt;Instructions and operations&lt;/h2&gt;

&lt;p&gt;An instruction consists of one or more components:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;An operation code (e.g. “subtract a from b”)&lt;/li&gt;
  &lt;li&gt;0-3 operands (e.g. “register a and register b, results in register c”)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As a virtual machine has the disadvantage of being …virtual, we must do whatever we can in terms of assuring good performance, so one of these instructions fit into one &lt;em&gt;machine word&lt;/em&gt;. Most hardware today is able to deal with 32-bit long chunks of data very efficiently, so inspired by &lt;a href=&quot;http://www.lua.org/&quot;&gt;Lua 5&lt;/a&gt; I chose a 32-bit representation for Sol’s instructions.&lt;/p&gt;

&lt;p&gt;Each instruction and its operands is encoded in one of three layouts (Behold, awesome ASCII art!.)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;OP ABC&lt;/strong&gt; — Operation OP with operands A, B and C:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0         5 | 6          13 | 14           22 | 23            31   Bit
------------|---------------|-----------------|-----------------
     OP     |       A       |        B        |        C           Field
------------|---------------|-----------------------------------
     6              8                9                 9           Bits
  [0..63]        [0..255]         [0..511]          [0..511]       Range
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Some operations only need two operands and can be made more efficient if one of those operands is large enough for common values. For this need we define an alternate layout of an instruction:&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;OP ABx&lt;/strong&gt; — Operation OP with operands A and Bs&lt;/td&gt;
      &lt;td&gt;Bu:&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code&gt;0         5 | 6          13 | 14                              31   Bit
------------|---------------|-----------------------------------
     OP     |       A       |              Bs/Bu                   Field
------------|---------------|-----------------------------------
     6              8                        18                    Bits
  [0..63]        [0..255]             Bu: [0..262143]              Range
                                      Bu: [-131071..131072]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A third class of operations only use one operand which size has a correlation with efficiency, so we define a third alternate layout of an instruction where the three operands are effectively collapsed into one 26-bit integer value:&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;OP Bxx&lt;/strong&gt; — Operation OP with operand Bss&lt;/td&gt;
      &lt;td&gt;Buu:&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code&gt;0         5 | 6                                               31   Bit
------------|---------------------------------------------------
     OP     |                     Bss/Buu                          Field
------------|---------------------------------------------------
     6                               26                            Bits
  [0..63]                   Buu: [0..67108863]                     Range
                            Bss: [-33554431..33554432]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A, B, C, Bu and Buu signify unsigned integers whilst Bs and Bss signify signed integers. As we can read above, there’s room for 64 operations and 256 registers (OP=6 bits, A=8 bits) with this configuration. More than we need :)&lt;/p&gt;

&lt;p&gt;Changing and maintaining instructions (operations + operands) is simple in Sol. I’ve intentionally gone to great lengths in order to make playing around with the instuction set easy. The file &lt;code&gt;instr.h&lt;/code&gt; contains a list of instructions:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  /* Control flow */ \
  _(YIELD,      ABC) /* suspend and reschedule */\
  _(JUMP,       Bss) /* PC += Bss */\
  _(CALL,       ABC) /* R(A), ... ,R(A+C-1) := R(A)(R(A+1), ... ,R(A+B)) */\
  _(RETURN,     AB_) /* return R(A), ... ,R(A+B-1) */\
  /* Data */ \
  _(LOADK,      ABu) /* R(A) = K(Bu) */\
  _(MOVE,       AB_) /* R(A) = R(B) */\
  _(DBGREG,     ABC) /* special: Debug dump register values */\
  /* Arithmetic */ \
  _(ADD,        ABC) /* R(A) = RK(B) + RK(C) */\
  _(SUB,        ABC) /* R(A) = RK(B) - RK(C) */\
  _(MUL,        ABC) /* R(A) = RK(B) * RK(C) */\
  ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/rsms/sol&quot;&gt;Sol’s source code&lt;/a&gt; is setup in such a way that changing this list is all that is required, apart from the actual implementation of each instruction. Adding or renaming an instruction automatically makes convenience symbols and functions available. Say that we add a &lt;code&gt;DING&lt;/code&gt; instruction which plays a little sound every time it’s executed:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  _(MUL,        ABC) /* R(A) = RK(B) * RK(C) */\
  _(DING,       Buu) /* A = sound number to play */\
  ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There’s now a new operation identifier available called &lt;code&gt;S_OP_DING&lt;/code&gt; as well as constructor function for encoding DING instructions:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SInstr  SInstr_DING(uint32_t value);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Running a program now that includes a DING operation will cause an error in the VM: “unexpected operation”. We haven’t implemented the DING behavior yet! Operations are (at the time of writing this) implemented in &lt;code&gt;sched_exec.h&lt;/code&gt; which is the core of the virtual machine as this is what reads and performs the instructions of a Sol program. It can be summed up like this:&lt;/p&gt;

&lt;p&gt;```c
void Execute(Instr* instructions) {
  Instr* pc = instructions;
  while (1) {
    switch (*++pc) {
    case S_OP_LOADK:
      // Read operands A and B from instruction *pc.
      // Put constant at B into register A.
      break;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;case S_OP_MOVE:
  // Read operands A and B from instruction *pc.
  // Put value of register B in register A.
  break;

...

} // switch   } // while } ```
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Pretty much a good old switch loop. When this C code is compiled with a modern compiler like Clang or GCC, it will be rather efficient as each of our virtual operations effectively corresponds to only a few machine instructions. This is where we need to add DING.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;c
    ...
    case S_OP_DING:
      // Read operand Buu from instruction *pc.
      uint32_t sound_index = SInstrGetBuu(*pc);
      // Find note for sound_index and play it
      SoundNote* note = SoundGetNote(sound_index);
      SoundPlay(note);
      break;
    ...
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Here the type &lt;code&gt;Sound&lt;/code&gt; as well as &lt;code&gt;SoundGet&lt;/code&gt; and &lt;code&gt;SoundPlay&lt;/code&gt; represents some kind of sound playing function that you provide. Now we can write Sol programs that play music:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;asm
define melody 0
  entry:
  DING   0      # play note 0
  DING   1      # play note 1
  DING   1      # play note 1
  DING   2      # play note 2
  DING   0      # play note 0
  RETURN 0  0   # return
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Pling, plong, plong, ding, pling!&lt;/p&gt;

&lt;h2 id=&quot;multitasking&quot;&gt;Multitasking&lt;/h2&gt;

&lt;p&gt;No toy VM can be presented without shame unless it’s able to &lt;a href=&quot;http://en.wikipedia.org/wiki/Computer_multitasking&quot;&gt;multitask&lt;/a&gt;; perform multiple things at once, or at least give the programmer the illusion of concurrency.&lt;/p&gt;

&lt;p&gt;Sol has an operation called “yield” which is able to pause a task in any state and later have that task resume at the exact same state.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://farm9.staticflickr.com/8468/8089711825_e00b434731_o.png&quot; alt=&quot;Sketch of tasks yielding&quot; /&gt;&lt;/p&gt;

&lt;p&gt;From the task’s perspective it never knew it was paused and resumed. This is a powerful primitive as we can implement many features on top of this. At the time of writing, Sol already has two different types of &lt;em&gt;yield&lt;/em&gt;: Yielding for other tasks (so they can run or be scheduled from I/O etc events), and yielding for a timer to expire. At the end of this article there are a few example programs, all of them making use of yield.&lt;/p&gt;

&lt;p&gt;Yield is used to implement &lt;a href=&quot;http://en.wikipedia.org/wiki/Computer_multitasking#Cooperative_multitasking.2Ftime-sharing&quot;&gt;&lt;em&gt;cooperative multitasking&lt;/em&gt;&lt;/a&gt; where all tasks cooperate for the use of processing resources. When a task has performed a series of computations and relieves control to another task, one of three things has happened:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;The task initiated an external (“blocking”) operation, like reading from a file or waiting for a certain time to occur,&lt;/li&gt;
  &lt;li&gt;the task completed and ended (it’s “main” function returned.),&lt;/li&gt;
  &lt;li&gt;or the task faulted, caused an error.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Most systems that communicate with its environment and abroad, like a web server or a text editor, spend most of its time (CPU time relative to real time) waiting for the environment to respond; e.g. producing data on a network socket, writing contents to a file or returning a stepper motors position. These systems often benefit from cooperative multitasking, in particular coherent, specialized systems (unlike operating systems which are general by nature).&lt;/p&gt;

&lt;p&gt;What Sol provides is essentially &lt;a href=&quot;http://en.wikipedia.org/wiki/Coroutine&quot;&gt;coroutines&lt;/a&gt; for concurrency. A nice feature with coroutines (aka “green threads” aka “user threads”) is their ability to run sequential code in a concurrent system. A task like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def read_file(name):
  f = open(name)
  data = read(f)
  close(f)
  return data
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Involves three “blocking” calls to the environment which causes the task to yield:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;open&lt;/code&gt; asks the operating system to open a file by &lt;code&gt;name&lt;/code&gt;. The file might get opened sometime in the future. The scheduler takes a note that the task is waiting for this to happen, removes it from the &lt;em&gt;run queue&lt;/em&gt; for the time being.&lt;/li&gt;
  &lt;li&gt;The OS tells the scheduler that “that file you wanted me to open, well here’s the file descriptor” and thus the scheduler places the task on the &lt;em&gt;run queue&lt;/em&gt; again.&lt;/li&gt;
  &lt;li&gt;The task receives the file descriptor representing the opened file&lt;/li&gt;
  &lt;li&gt;The task again calls to the environment, this time asking to &lt;code&gt;read&lt;/code&gt; the contents of &lt;code&gt;f&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Same thing as before, the scheduler tells the OS, takes a note, unschedules the task and continue with executing other tasks.&lt;/li&gt;
  &lt;li&gt;The OS tells the scheulder “I’ve read that file you asked me to read, here’s the data” (in reality this is slightly more complicated, but the principles are the same)&lt;/li&gt;
  &lt;li&gt;The scheduler queues the task, runs it.&lt;/li&gt;
  &lt;li&gt;Same thing with the &lt;code&gt;close&lt;/code&gt; function.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For the programmer it’s easy to follow the flow of her program.&lt;/p&gt;

&lt;p&gt;Comparing the above synchronous program to an asynchronous version:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def read_file(name, callback):
  open(name, def (error, f):
    if (error):
      callback(error)
    else:
      read(f, def (read_error, data):
        close(f, def (error):
          callback(error, data)
        )
      )
  )
  # returns here before the file has been opened
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Clearly harder to follow. A task in Sol can spawn new tasks in order to perform several things at the same time, like writing a file while replying over the network.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def write_and_reply(destination_id, message):
  writer = write_file(destination_id + &quot;.msg&quot;, message)
  send_message(destination_id, message)
  while (recv(writer) != TaskEnd) noop  # wait for write_file to end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, as the &lt;a href=&quot;http://en.wikipedia.org/wiki/Computer_multitasking#Cooperative_multitasking.2Ftime-sharing&quot;&gt;Wikipedia section on cooperative multitasking&lt;/a&gt; mentions…&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Because a cooperatively multitasked system relies on each process regularly giving up time to other processes on the system, one poorly designed program can consume all of the CPU time for itself or cause the whole system to hang.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This can happen when a program performs a very lengthy set of computations and can cause all kinds of problems, especially for other tasks relying on timers. As the Sol scheduler checks for timer expiration only between execution of tasks, a timer might effectively fire long after it was supposed to. Imagine controlling a toy &lt;a href=&quot;http://en.wikipedia.org/wiki/Quadrotor&quot;&gt;quadrotor&lt;/a&gt; where one task needs to update one rotor’s angle each 50 milliseconds, and another task consumes a wholesome 200 milliseconds, then your quadrotor might just crash and burn.&lt;/p&gt;

&lt;p&gt;To address this Sol employs an &lt;em&gt;operation cost counter&lt;/em&gt;. Each task is given a predefined amount of “operation value” per execution iteration (when the scheduler runs a task’s program). When the &lt;em&gt;operation cost counter&lt;/em&gt; reaches its limit, the task is simply forced to yield to other tasks. In the source code, look for &lt;code&gt;S_VM_EXEC_LIMIT&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;some-examples&quot;&gt;Some examples&lt;/h2&gt;

&lt;p&gt;The code below is expressed in a simplified assembly language that is almost 1:1 with the C API for defining these programs programatically, and so the assembly language itself should be considered irrelevant beyond explaining the instructions executed.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;In the output, lines like these: &lt;code&gt;[vm] ______________ ...&lt;/code&gt; denote when the scheduler regains control after running a task and the task either returned or yielded. This is one “execution iteration”. When running multiple tasks, you will usually see tasks interleved in round-robin order between these “execution iteration” marker lines.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;In the output, lines starting with “…” are comments and/or simplifications and not part of the actual output.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;In assembly comments, &lt;code&gt;R(x)&lt;/code&gt; means “Register x”, &lt;code&gt;RK(x)&lt;/code&gt; means “Register x if x is less than k else Constant (x-k)” where k is a special value, &lt;code&gt;K(x)&lt;/code&gt; means “Constant x”.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;In assembly comments, &lt;code&gt;PC&lt;/code&gt; signifies the “program counter” which is sort of a cursor to the instructions of a program. It is incremented by one for each instruction executed. Some instructions will further modify this counter, like for instance the &lt;code&gt;JUMP&lt;/code&gt; instruction.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;example-1-while-x--0-yield-&quot;&gt;Example 1: while x &amp;gt; 0 yield …&lt;/h3&gt;

&lt;p&gt;While the variable x is greater than zero, decrement &lt;code&gt;x&lt;/code&gt; by one and yield to the
scheduler, letting other tasks run. Eventually return.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;py
def main():
  x = 5
  while (x &amp;gt; 0):
    x = x - 1
    yield
  return
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Assembly:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;asm
define main 0
  CONST 5           # K(0) = 5
  CONST 0           # K(1) = 0
  CONST 1           # K(2) = 1
  entry:
  LOADK  0  0       # R(0) = K(0)
  LE     0  0  256  # (0 == RK(k+1) &amp;lt; RK(0)) ? continue else PC++
  JUMP   3          # PC += 3 to RETURN
  SUB    0  0  257  # R(0) = R(0) - RK(k+1)
  YIELD  0  0  0    # yield A=type=sched
  JUMP   -5         # PC -= 5 to LE
  RETURN 0  0       # return
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Output when running in debug mode:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
$ build/debug/bin/sol
Sol 0.1.0 x64
[vm] ______________ ______________ __________ _______ ____ ______________
[vm] Task           Function       PC         Op      Values
[vm] 0x7fdf28c03c00 0x7fdf28c000e0 0          LOADK   AB:    0,   0
[vm] 0x7fdf28c03c00 0x7fdf28c000e0 1          LE      ABC:   0,   0, 256
[vm] 0x7fdf28c03c00 0x7fdf28c000e0 3          SUB     ABC:   0,   0, 257
[vm] 0x7fdf28c03c00 0x7fdf28c000e0 4          YIELD   ABC:   0,   0,   0
[vm] ______________ ______________ __________ _______ ____ ______________
[vm] Task           Function       PC         Op      Values
[vm] 0x7fdf28c03c00 0x7fdf28c000e0 5          JUMP    Bss:       -5
[vm] 0x7fdf28c03c00 0x7fdf28c000e0 1          LE      ABC:   0,   0, 256
[vm] 0x7fdf28c03c00 0x7fdf28c000e0 3          SUB     ABC:   0,   0, 257
[vm] 0x7fdf28c03c00 0x7fdf28c000e0 4          YIELD   ABC:   0,   0,   0
[vm] ______________ ______________ __________ _______ ____ ______________
...three more execution iterations identical to the above block...
[vm] ______________ ______________ __________ _______ ____ ______________
[vm] Task           Function       PC         Op      Values
[vm] 0x7fdf28c03c00 0x7fdf28c000e0 5          JUMP    Bss:       -5
[vm] 0x7fdf28c03c00 0x7fdf28c000e0 1          LE      ABC:   0,   0, 256
[vm] 0x7fdf28c03c00 0x7fdf28c000e0 2          JUMP    Bss:        3
[vm] 0x7fdf28c03c00 0x7fdf28c000e0 6          RETURN  AB:    0,   0
Scheduler runloop exited.
&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;example-2-function-calls-and-timers&quot;&gt;Example 2: Function calls and timers&lt;/h3&gt;

&lt;p&gt;This program uses two functions. The entry point is the &lt;code&gt;main&lt;/code&gt; function which simply
calls the &lt;code&gt;kitten&lt;/code&gt; function with one argument ‘500’. The &lt;code&gt;kitten&lt;/code&gt; function “sleeps” for
the number of milliseconds passed to it (as the first argument.) The &lt;code&gt;kitten&lt;/code&gt; function
then returns the number “123” to the caller—the &lt;code&gt;main&lt;/code&gt; function—which dumps register values and
finally returns, causing the task to exit and subsequently the scheduler and the VM too to exit.&lt;/p&gt;

&lt;p&gt;Assembly:&lt;/p&gt;

&lt;p&gt;```asm
define kitten 1     # Arguments: (R(0)=sleep_ms)
  CONST  123        # K(0) = 123
  entry:
  YIELD  1  0  0    # yield A=type=timer, RK(B)=R(0)=arg0
  LOADK  0  0       # R(0) = K(0) = 123
  RETURN 0  1       # return R(0)..R(0) = R(0) = 123&lt;/p&gt;

&lt;p&gt;define main 0       # Arguments: ()
  CONST  @kitten    # K(0) = &lt;func kitten=&quot;&quot;&gt;
  CONST  500        # K(1) = 500
  entry:
  LOADK  0  0       # R(0) = K(0) = the kitten function
  LOADK  1  1       # R(1) = K(1) = 500
  CALL   0  1  1    # R(0)..R(0) = R(0)(R(1)..R(1)) = a(R(1))
  DBGREG 0  1  0    # VM debug function that dumps register values
  RETURN 0  0       # return
```&lt;/func&gt;&lt;/p&gt;

&lt;p&gt;Output when running in debug mode:&lt;/p&gt;

&lt;p&gt;```
$ time build/debug/bin/sol
Sol 0.1.0 x64
[vm] &lt;strong&gt;__&lt;/strong&gt;&lt;strong&gt;__&lt;/strong&gt;__ &lt;strong&gt;__&lt;/strong&gt;&lt;strong&gt;__&lt;/strong&gt;__ &lt;strong&gt;__&lt;/strong&gt;&lt;strong&gt;__ __&lt;/strong&gt;&lt;strong&gt;_ __&lt;/strong&gt; &lt;strong&gt;__&lt;/strong&gt;&lt;strong&gt;__&lt;/strong&gt;__
[vm] Task           Function       PC         Op      Values
[vm] 0x7f8c9bc03bf0 0x7f8c9bc03910 0          LOADK   AB:    0,   0
[vm] 0x7f8c9bc03bf0 0x7f8c9bc03910 1          LOADK   AB:    1,   1
[vm] 0x7f8c9bc03bf0 0x7f8c9bc03910 2          CALL    ABC:   0,   1,   1
[vm] 0x7f8c9bc03bf0 0x7f8c9bc000e0 1          YIELD   ABC:   1,   0,   0
D Timer scheduled to trigger after 500.000000 ms (sched.c:81)
# …time passes and in this case the scheduler is idling…
D Timer triggered – scheduling task (sched.c:57)
[vm] &lt;strong&gt;__&lt;/strong&gt;&lt;strong&gt;__&lt;/strong&gt;__ &lt;strong&gt;__&lt;/strong&gt;&lt;strong&gt;__&lt;/strong&gt;__ &lt;strong&gt;__&lt;/strong&gt;&lt;strong&gt;__ __&lt;/strong&gt;&lt;strong&gt;_ __&lt;/strong&gt; &lt;strong&gt;__&lt;/strong&gt;&lt;strong&gt;__&lt;/strong&gt;__
[vm] Task           Function       PC         Op      Values
[vm] 0x7f8c9bc03bf0 0x7f8c9bc000e0 2          LOADK   AB:    0,   0
[vm] 0x7f8c9bc03bf0 0x7f8c9bc000e0 3          RETURN  AB:    0,   1
[vm] 0x7f8c9bc03bf0 0x7f8c9bc03910 3          DBGREG 
D [vm] R(0) = 123.000000 (sched_exec.h:214)
D [vm] R(1) = 500.000000 (sched_exec.h:215)
D [vm] R(0) = 123.000000 (sched_exec.h:216)
[vm] 0x7f8c9bc03bf0 0x7f8c9bc03910 4          RETURN  AB:    0,   0
Scheduler runloop exited.&lt;/p&gt;

&lt;p&gt;real  0m0.504s
user  0m0.001s
sys   0m0.001s
```&lt;/p&gt;

&lt;h3 id=&quot;example-3-multitasking&quot;&gt;Example 3: Multitasking&lt;/h3&gt;

&lt;p&gt;Here we run three tasks, each running the program in &lt;em&gt;Example 1&lt;/em&gt;:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
$ build/debug/bin/sol
Sol 0.1.0 x64
[sched 0x7fc219403930] run queue:
  [task 0x7fc219403c00] -&amp;gt; [task 0x7fc219403cd0] -&amp;gt; [task 0x7fc219403da0]
[vm] ______________ ______________ __________ _______ ____ ______________
[vm] Task           Function       PC         Op      Values
[vm] 0x7fc219403c00 0x7fc2194000e0 0          LOADK   AB:    0,   0
[vm] 0x7fc219403c00 0x7fc2194000e0 1          LE      ABC:   0,   0, 256
[vm] 0x7fc219403c00 0x7fc2194000e0 3          SUB     ABC:   0,   0, 257
[vm] 0x7fc219403c00 0x7fc2194000e0 4          YIELD   ABC:   0,   0,   0
[vm] ______________ ______________ __________ _______ ____ ______________
[vm] Task           Function       PC         Op      Values
[vm] 0x7fc219403cd0 0x7fc2194000e0 0          LOADK   AB:    0,   0
[vm] 0x7fc219403cd0 0x7fc2194000e0 1          LE      ABC:   0,   0, 256
[vm] 0x7fc219403cd0 0x7fc2194000e0 3          SUB     ABC:   0,   0, 257
[vm] 0x7fc219403cd0 0x7fc2194000e0 4          YIELD   ABC:   0,   0,   0
[vm] ______________ ______________ __________ _______ ____ ______________
[vm] Task           Function       PC         Op      Values
[vm] 0x7fc219403da0 0x7fc2194000e0 0          LOADK   AB:    0,   0
[vm] 0x7fc219403da0 0x7fc2194000e0 1          LE      ABC:   0,   0, 256
[vm] 0x7fc219403da0 0x7fc2194000e0 3          SUB     ABC:   0,   0, 257
[vm] 0x7fc219403da0 0x7fc2194000e0 4          YIELD   ABC:   0,   0,   0
[vm] ______________ ______________ __________ _______ ____ ______________
[vm] Task           Function       PC         Op      Values
[vm] 0x7fc219403c00 0x7fc2194000e0 5          JUMP    Bss:       -5
[vm] 0x7fc219403c00 0x7fc2194000e0 1          LE      ABC:   0,   0, 256
[vm] 0x7fc219403c00 0x7fc2194000e0 3          SUB     ABC:   0,   0, 257
[vm] 0x7fc219403c00 0x7fc2194000e0 4          YIELD   ABC:   0,   0,   0
[vm] ______________ ______________ __________ _______ ____ ______________
...The above block of instruction is repeated three times in interleved
   round-robin order for each task. Then:
[vm] ______________ ______________ __________ _______ ____ ______________
[vm] Task           Function       PC         Op      Values
[vm] 0x7fc219403c00 0x7fc2194000e0 5          JUMP    Bss:       -5
[vm] 0x7fc219403c00 0x7fc2194000e0 1          LE      ABC:   0,   0, 256
[vm] 0x7fc219403c00 0x7fc2194000e0 2          JUMP    Bss:        3
[vm] 0x7fc219403c00 0x7fc2194000e0 6          RETURN  AB:    0,   0
[vm] ______________ ______________ __________ _______ ____ ______________
[vm] Task           Function       PC         Op      Values
[vm] 0x7fc219403cd0 0x7fc2194000e0 5          JUMP    Bss:       -5
[vm] 0x7fc219403cd0 0x7fc2194000e0 1          LE      ABC:   0,   0, 256
[vm] 0x7fc219403cd0 0x7fc2194000e0 2          JUMP    Bss:        3
[vm] 0x7fc219403cd0 0x7fc2194000e0 6          RETURN  AB:    0,   0
[vm] ______________ ______________ __________ _______ ____ ______________
[vm] Task           Function       PC         Op      Values
[vm] 0x7fc219403da0 0x7fc2194000e0 5          JUMP    Bss:       -5
[vm] 0x7fc219403da0 0x7fc2194000e0 1          LE      ABC:   0,   0, 256
[vm] 0x7fc219403da0 0x7fc2194000e0 2          JUMP    Bss:        3
[vm] 0x7fc219403da0 0x7fc2194000e0 6          RETURN  AB:    0,   0
Scheduler runloop exited.
&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;source-code&quot;&gt;Source code&lt;/h2&gt;

&lt;p&gt;Released free under a very permissive MIT-style license at &lt;a href=&quot;https://github.com/rsms/sol&quot;&gt;https://github.com/rsms/sol&lt;/a&gt;.&lt;/p&gt;
</description>
        <pubDate>Sun, 14 Oct 2012 00:00:00 +0800</pubDate>
        <link>/languages/2012/10/14/sol-a-sunny-little-virtual-machine.html</link>
        <guid isPermaLink="true">/languages/2012/10/14/sol-a-sunny-little-virtual-machine.html</guid>
        
        <category>programming</category>
        
        
        <category>languages</category>
        
      </item>
    
      <item>
        <title>Our own little computer language</title>
        <description>&lt;p&gt;Let’s write our own programming language. It’ll be fun and we will learn some key tools for processing structured data, performing semantic analysis, how to make a computer execute code, and all this using modern JavaScript.&lt;/p&gt;

&lt;p&gt;We will create five major components, each outlined in a separate article:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Lexical analyzer&lt;/li&gt;
  &lt;li&gt;Semantic parser&lt;/li&gt;
  &lt;li&gt;Code generator&lt;/li&gt;
  &lt;li&gt;Management and support&lt;/li&gt;
  &lt;li&gt;Runtime library&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Today we will actually do two things: Define a first version of our language’ lexicon, and write a lexical analyzer—or &lt;em&gt;lexer&lt;/em&gt;—which performs &lt;em&gt;lexical analysis&lt;/em&gt; of our language. From &lt;a href=&quot;http://en.wikipedia.org/wiki/Lexical_analysis&quot;&gt;Wikipedia&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;lexical analysis is the process of converting a sequence of characters into a sequence of tokens. A program or function which performs lexical analysis is called a lexical analyzer, lexer, or scanner.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Our &lt;em&gt;lexer&lt;/em&gt; will understand the basic building blocks of our language, similar to what a word and punctuation are in natural language text. Naturally we need to decide which these words and punctuation are. I think this is one of the most fun parts of writing your own language, as we are completely free to design our language.&lt;/p&gt;

&lt;p&gt;A lexer is usually the first part in the &lt;em&gt;evaluation pipeline&lt;/em&gt;:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Source code → Lexer → Parser → Code generator → Execution&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;language-lexicon-and-syntax&quot;&gt;Language lexicon and syntax&lt;/h2&gt;

&lt;p&gt;Let’s formulate the basic building blocks of our language. Before we write anything, let’s take a minute and think about what kind of language we wish to design. We don’t have to commit to anything yet, but it will be easier for us to make progress if we have an idea of what we are trying to accomplish.&lt;/p&gt;

&lt;p&gt;If we have the answers to the following to questions, our work will be easier.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Are linebreaks significant?&lt;/li&gt;
  &lt;li&gt;Is leading whitespace significant?&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;A language like C does not care about whitespace at all, except for separating keywords, whilst a language like Python cares about both linebreaks and leading whitespace. Let’s say “yes” to both these questions. Our language might care about both linebreaks and leading whitespace.&lt;/p&gt;

&lt;h3 id=&quot;syntax&quot;&gt;Syntax&lt;/h3&gt;

&lt;p&gt;Here’s a &lt;a href=&quot;http://en.wikipedia.org/wiki/Backus%E2%80%93Naur_Form&quot;&gt;BNF&lt;/a&gt;-style sketch of the language I have in mind for this tutorial. Feel free to make up your own version.&lt;/p&gt;

&lt;p&gt;```none
Expression           = ExpressionGroup | Number | Text | Path | List | Map
ExpressionGroup      = “(“ Expression* “)”
Line                 = Linebreak Space*&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Whitespace           = Linebreak&lt;/td&gt;
      &lt;td&gt;Space&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Linebreak            = U+000A..U+000D&lt;/td&gt;
      &lt;td&gt;U+0085&lt;/td&gt;
      &lt;td&gt;U+2028&lt;/td&gt;
      &lt;td&gt;U+2029&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Space                = U+0009&lt;/td&gt;
      &lt;td&gt;U+0020&lt;/td&gt;
      &lt;td&gt;U+00A0&lt;/td&gt;
      &lt;td&gt;U+180E&lt;/td&gt;
      &lt;td&gt;U+2000..U+200B&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;U+202F&lt;/td&gt;
      &lt;td&gt;U+205F&lt;/td&gt;
      &lt;td&gt;U+3000&lt;/td&gt;
      &lt;td&gt;U+FEFF&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Number               = IntegerNumber | HexIntegerNumber | FractionalNumber
IntegerNumber        = DecimalDigit+
DecimalDigit         = 0..9
HexIntegerNumber     = “0x” HexDigit+
HexDigit             = 0..9 | A..F | a..f
FractionalNumber     = DecimalDigit+ “.” DecimalDigit* FractionExponent?
FractionalExponent   = (“E” | “e”) (“-“ | “+”)? DecimalDigit+&lt;/p&gt;

&lt;p&gt;Text                 = “’” TextCharacter* “’”
TextCharacter        = U+0021..U+0026
                     | U+0028..U+005B
                     | “&quot; TextEscCharacter
                     | U+005D..U+FFEE
TextEscCharacter     = “&quot; | “’” | “t” | “n” | “r” | UnicodeValue
UnicodeValue         = “u” HexDigit{4} | “U” HexDigit{8}&lt;/p&gt;

&lt;p&gt;Path                 = Symbol (“.” Symbol)*
Symbol               = &amp;lt;SymbolCharacter except 0..9&amp;gt; SymbolCharacter*
SymbolCharacter      = &lt;visiblecharacter except=&quot;&quot; singleterminator=&quot;&quot;&gt;
VisibleCharacter     = &amp;lt;UnicodeCharacter except Whitespace | ControlCharacter&amp;gt;
UnicodeCharacter     = U+0000..U+FFFE
ControlCharacter     = U+0000..U+0020 | U+007F..00A0 | U+FFEF..U+FFFF
SingleTerminator     = &quot;(&quot; | &quot;)&quot; | &quot;.&quot; | &quot;:&quot; | &quot;[&quot; | &quot;]&quot; | &quot;{&quot; | &quot;}&quot;&lt;/visiblecharacter&gt;&lt;/p&gt;

&lt;p&gt;List                 = “[” Expression* “]”&lt;/p&gt;

&lt;p&gt;Map                  = “{“ MapPair* “}”
MapPair              = MapKey “:” Expression
MapKey               = Symbol | Text
```&lt;/p&gt;

&lt;p&gt;This format, usually referred to as BNF (although not actual strict BNF), is a way of expressing a syntax in terms of simple reductions. A quick guide to general BNF format:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;Foo = Bar | Baz&lt;/code&gt; — “Foo” means either exactly one Bar or exactly one Baz.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Bar?&lt;/code&gt; — Zero or one “Bar” (a trailing “?” means “optional”)&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Bar*&lt;/code&gt; — Zero or more “Bar” in succession&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Bar+&lt;/code&gt; — One or more “Bar” in succession&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Bar{4}&lt;/code&gt; — Exactly 4 “Bar” in succession&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;A..F&lt;/code&gt; — Exactly one of the items in the natural sequence (here, A, B, C, D, E or F)&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;&quot;Bar&quot;&lt;/code&gt; — The literal “Bar”&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;(A | B) C&lt;/code&gt; — “(“ and “)” groups an anonymous reduction, here meaning “one of A or B, then one C”&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;U+2192&lt;/code&gt; — A Unicode character value (in this case the RIGHTWARDS ARROW codepoint)&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;&amp;lt;Foo except A and C&amp;gt;&lt;/code&gt; — Simplification of a reduction of “Foo”. Generally not recommented but useful in early stages of design.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The above language is definitely incomplete (no functions or operators), but is a great start and to be honest it’s more than we need to get started. It would allow source code like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Hello = (bar baz) -&amp;gt;
  ה = can-haz [bar &#39;bar bara&#39;]
  54.8 * ה
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first step to interpreting this code is to perform &lt;em&gt;lexical analysis&lt;/em&gt;. As discussed earlier this means that a stream of bytes is the input and a stream of tokens is the result. Given our partial language specification, the above source should produce the following tokens:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Symbol(&quot;Hello&quot;)&lt;/code&gt;,
&lt;code&gt;Symbol(&quot;=&quot;)&lt;/code&gt;,
&lt;code&gt;LeftParen&lt;/code&gt;,
&lt;code&gt;Symbol(&quot;bar&quot;)&lt;/code&gt;,
&lt;code&gt;Symbol(&quot;baz&quot;)&lt;/code&gt;,
&lt;code&gt;RightParen&lt;/code&gt;,
&lt;code&gt;Symbol(&quot;-&amp;gt;&quot;)&lt;/code&gt;,
&lt;code&gt;Line(with 2 spaces)&lt;/code&gt;,&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Symbol(&quot;ה&quot;)&lt;/code&gt;,
&lt;code&gt;Symbol(&quot;=&quot;)&lt;/code&gt;,
&lt;code&gt;Symbol(&quot;can-haz&quot;)&lt;/code&gt;,
&lt;code&gt;LeftSquareBracket&lt;/code&gt;,
&lt;code&gt;Symbol(&quot;bar&quot;)&lt;/code&gt;,
&lt;code&gt;Text(&quot;bar bara&quot;)&lt;/code&gt;,
&lt;code&gt;RightSquareBracket&lt;/code&gt;,
&lt;code&gt;Line(with 2 spaces)&lt;/code&gt;,&lt;/p&gt;

&lt;p&gt;&lt;code&gt;FractionalNumber(&quot;54.8&quot;)&lt;/code&gt;,
&lt;code&gt;Symbol(&quot;*&quot;)&lt;/code&gt;,
&lt;code&gt;Symbol(&quot;ה&quot;)&lt;/code&gt;,
&lt;code&gt;Line(with 0 spaces)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;With our current language lexicon and syntax we are able to formulate more complex structures that the above example, for instance:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Text.join = (list-of-text glue) -&amp;gt;
  result = nil
  for text in list-of-text
    result = if (result == nil) text
             else result + glue + text
  result

(print (Text.join [&#39;Yet another&#39; &#39;Hello&#39; &#39;world&#39;] &#39; &#39;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, let’s stick to the previous simpler example for now.&lt;/p&gt;

&lt;p&gt;This is an excellent time to take a break and play around with some different imaginary language syntax. Remember that the &lt;em&gt;lexer&lt;/em&gt; only needs to know about &lt;em&gt;what a word is&lt;/em&gt; not &lt;em&gt;all the possible words&lt;/em&gt; or even the sequence of words. When I say “words” here I mean the smallest building blocks of the syntax, or &lt;em&gt;tokens&lt;/em&gt; as they are usually called. Let’s call each small unit of meaning a “token” from here on forward.&lt;/p&gt;

&lt;h2 id=&quot;behold-a-lexer&quot;&gt;Behold, a lexer&lt;/h2&gt;

&lt;p&gt;Remember the &lt;em&gt;evaluation pipeline&lt;/em&gt;?&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Source code → Lexer → Parser → Code generator → Execution&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Parsing and dealing with code is inherently a flowing system with no specific beginning or end. Sure, if we read the source from a file the file will have a start and it will have an ending, but let’s write a pipeline that is universal and has &lt;em&gt;incremental&lt;/em&gt; functionality. In contrary to traditional &lt;em&gt;batch&lt;/em&gt; lexers, an &lt;em&gt;incremental&lt;/em&gt; lexer is able to iteratively analyze a continuous stream of characters and with little delay produce tokens on-the-fly. The tokens produced by our lexer will even be able to retain a persistent “snapshot” of the lexer’s state, for the abilitly to perform an incremental modification from a certain point. However, our lexer will merely make this possible but not directly provide this functionality.&lt;/p&gt;

&lt;p&gt;Given these requirements of being able to pause, resume and change source as we are producing tokens, there are not many implementation approaches available to us. In a language that has functions with local variables (usually implemented with a stack) a &lt;em&gt;batch lexer&lt;/em&gt; can be efficiently implemented with a function-based &lt;em&gt;recursive decent&lt;/em&gt; approach, where each token reduction (see our BNF-style language definition) is represented by a function that calls another function depending on the source character at hand.&lt;/p&gt;

&lt;p&gt;Here is pseudo-code implementing a recursive decent approach (this particular one is actually not recursive, but could very well become so), able to handle the &lt;code&gt;Text&lt;/code&gt; part of our syntax:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Lexer:
  next_char = nil
  input = &quot;&quot;
  input_offs = 0

  def ReadToken():
    return this.ReadExpression()

  def ReadExpression():
    if this.next_char == &quot;&#39;&quot;:
      this.ReadNextChar() # Consume &quot;&#39;&quot;
      return this.ReadText()
    else if ...

  def ReadText():
    token = {type = TEXT, value = &quot;&quot;}
    prev_was_escape = false
    while this.next_char:
      if prev_was_escape:
        prev_was_escape = false
        token.value = concat(token.value, this.next_char)
      else if this.next_char == &quot;\\&quot;:
        prev_was_escape = true
        continue
      else if this.next_char == &quot;&#39;&quot;:
        break
      else:
        token.value = concat(token.value, this.next_char)
    this.ReadNextChar() # Consume &quot;&#39;&quot;
    return token

  def ReadNextChar():
    this.next_char = this.input[this.input_offs++]

L = Lexer()
L.SetInput(&quot;&#39;Hello world&#39;&quot;)
L.ReadToken()  # -&amp;gt; {type=TEXT, value=&quot;Hello world&quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This works fine for source input that is provided as one continuous sequence.
If we were to pause a batch lexer like this, it would either imply a very complex and probably inefficient code which records and stuffs away the current call stack (essentially co-routines or green threads), or abort and retry from the beginning again later.&lt;/p&gt;

&lt;p&gt;Say the source &lt;code&gt;&#39;Hello world&#39;&lt;/code&gt; arrives in two chunks and we try to apply the above batch lexer:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. SetInput(&quot;&#39;Hello wo&quot;)
2. ReadToken()  # -&amp;gt; nil
3. # Some time passes...
4. SetInput(&quot;rld&#39;&quot;)
5. ReadToken()  # -&amp;gt; something not a string
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When &lt;code&gt;ReadText&lt;/code&gt; is called, &lt;code&gt;next_char&lt;/code&gt; will be &lt;code&gt;nil&lt;/code&gt; before the loop sees a terminating “’” character, and since all state is kept on the stack it will be lost when the function returns. Thus the second call at line 4 and 5 will begin reading with a reset state. No cigar.&lt;/p&gt;

&lt;p&gt;So we realized that the state of the lexer must be held by the lexer itself and in a way that can be represented persistently (e.g. as data in memory).&lt;/p&gt;

&lt;p&gt;Looking again at the pseudo code above for a batch lexer, we will look at what actually happens by unrolling the code:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;The lexer is asked to read the next token&lt;/li&gt;
  &lt;li&gt;At this point the lexer has no context so the only thing it can do is to parse an “Expression”. Calling the “ReadExpression” function creates a new stack call entry. This is the state of what we are reading.&lt;/li&gt;
  &lt;li&gt;Okay, so we are reading an expression. Since we have no previous information about where in an expression we are, let’s look at the current character of the source code (it’s “’”)&lt;/li&gt;
  &lt;li&gt;Since the character is a “’” we know that a “Text” token is coming up. Call “ReadText” to enter a state of “reading text”.&lt;/li&gt;
  &lt;li&gt;Create a new token and store it into the variable &lt;code&gt;token&lt;/code&gt; that is kept on the stack. We need to keep track of the previous character since “\c” and “c” means different things. This is also kept as a variable &lt;code&gt;prev_was_escape&lt;/code&gt; living on the stack (or in the function’s scope, depending on the language we write this in, but whatever).&lt;/li&gt;
  &lt;li&gt;Look at the next character, look at &lt;code&gt;prev_was_escape&lt;/code&gt; and append &lt;code&gt;next_char&lt;/code&gt; to the token value as we read.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Essentially each step is a certain code branch that flow into other code branches depending on certain branch-related values. So let’s move those values into a “lexer context” object which we instead pass around between readings.&lt;/p&gt;

&lt;p&gt;Let’s rewrite the previous batch lexer using this strategy.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def Lexer():
  return {input = &quot;&quot;, input_offs = 0, token = nil, next_char = nil}

def ReadToken(L):
  result = nil
  while L.next_char:
    if L.token == nil:
      # Entry state
      if L.next_char == &quot;&#39;&quot;:
        L.token = {type = TEXT, value = &quot;&quot;, prev_was_escape = false}
        ReadNextChar(L) # Consume &quot;&#39;&quot;
      else:
        ...
    else if L.token.type == TEXT:
      if L.token.prev_was_escape:
        L.token.prev_was_escape = false
        token.value = concat(token.value, L.next_char)
      else if L.next_char == &quot;\\&quot;:
        L.token.prev_was_escape = true
      else if L.next_char == &quot;&#39;&quot;:
        result = L.token
        delete result.prev_was_escape
        L.token = nil
      else:
        token.value = concat(token.value, L.next_char)
      ReadNextChar(L)
    else:
      ...
  return result

L = Lexer()
SetInput(L, &quot;&#39;Hello wo&quot;)
ReadToken(L)  # -&amp;gt; nil
SetInput(L, &quot;rld&#39;&quot;)
ReadToken(L)  # -&amp;gt; {type=TEXT, value=&quot;Hello world&quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We simply moved the state into a structure (referenced to as &lt;code&gt;L&lt;/code&gt; above) which we pass around instead of storing the state values on the stack. The function calls were replaced by logical code branches. The &lt;code&gt;token&lt;/code&gt; structure above is used to carry token code-branch specific state. This design not only performs better (in most languages) but it also meets our requirements of being able to be paused and resumed.&lt;/p&gt;

&lt;h3 id=&quot;a-javascript-implementation&quot;&gt;A JavaScript implementation&lt;/h3&gt;

&lt;p&gt;For this tutorial article series I’ve chosen JavaScript as it’s easily accessible, a very popular language, has built-in Unicode support (good since we are to be analyzing text) and runs almost anywhere.&lt;/p&gt;

&lt;p&gt;Before writing or running any code, install Node.js — a free, modern and efficient JavaScript environment that let’s you run JavaScript programs in a terminal session (just like Python, Ruby, Perl or any other regular program). It takes just a minute to download and install, so don’t hesitate: &lt;a href=&quot;http://nodejs.org/download/&quot;&gt;nodejs.org/download&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Now, let’s have a look at the lexer. It’s easiest if you &lt;a href=&quot;https://github.com/rsms/prog-lang-tutorial.git&quot;&gt;clone or fork the Git repository&lt;/a&gt; at &lt;a href=&quot;https://github.com/rsms/prog-lang-tutorial&quot;&gt;https://github.com/rsms/prog-lang-tutorial&lt;/a&gt; and have a look in the “01-lexer” directory. There is a file called &lt;em&gt;&lt;a href=&quot;https://github.com/rsms/prog-lang-tutorial/blob/master/01-lexer/lexer-demo.js&quot;&gt;lexer-demo.js&lt;/a&gt;&lt;/em&gt; — a simple program that imports our lexer and applies some sample source. Essentially it imports the Lexer module and does something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var L = Lexer(), token;
L.appendSource(&#39;Foo (bar baz)&#39;);
while ((token = L.next(source_ended))) {
  console.log(Lexer.TOKEN_NAMES[token.type], token);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The interesting part is in the &lt;em&gt;&lt;a href=&quot;https://github.com/rsms/prog-lang-tutorial/blob/master/01-lexer/lib/mylang/Lexer.js&quot;&gt;lib/mylang/Lexer.js&lt;/a&gt;&lt;/em&gt; file, so let’s quickly look through the different sections of the Lexer code.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Create a new Lexer object.
function Lexer() {
  return Object.create(Lexer.prototype, ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This function creates new Lexer objects with initial state. We call this function each time we start reading a new source stream.&lt;/p&gt;

&lt;p&gt;Next up is a set of token definitions. This is where we define each of the different token types that our language is constructed from.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var LINE                 = deftok(&#39;LINE&#39;);
var LEFT_PAREN           = deftok(&#39;LEFT_PAREN&#39;,           &#39;(&#39;);
var RIGHT_PAREN          = deftok(&#39;RIGHT_PAREN&#39;,          &#39;)&#39;);
var LEFT_SQUARE_BRACKET  = deftok(&#39;LEFT_SQUARE_BRACKET&#39;,  &#39;[&#39;);
var RIGHT_SQUARE_BRACKET = deftok(&#39;RIGHT_SQUARE_BRACKET&#39;, &#39;]&#39;);
var LEFT_CURLY_BRACKET   = deftok(&#39;LEFT_CURLY_BRACKET&#39;,   &#39;{&#39;);
var RIGHT_CURLY_BRACKET  = deftok(&#39;RIGHT_CURLY_BRACKET&#39;,  &#39;}&#39;);
var FULL_STOP            = deftok(&#39;FULL_STOP&#39;,            &#39;.&#39;);
var COLON                = deftok(&#39;COLON&#39;,                &#39;:&#39;);
var DECIMAL_NUMBER       = deftok(&#39;DECIMAL_NUMBER&#39;);
var HEX_NUMBER           = deftok(&#39;HEX_NUMBER&#39;);
var FRACTIONAL_NUMBER    = deftok(&#39;FRACTIONAL_NUMBER&#39;);
var SYMBOL               = deftok(&#39;SYMBOL&#39;);
var TEXT                 = deftok(&#39;TEXT&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;deftok&lt;/code&gt; helper function simply assigns the token a unique number identifier and if a second argument is given, associates that token id with a single character value (this is stored in the internal map &lt;code&gt;SINGLE_TOKENS&lt;/code&gt;). The Lexer will be able to look up a character value in this map and if it’s there, immediately terminate any currently reading token. This is useful for single-character tokens which might appear immediately before or after for instance a symbol.&lt;/p&gt;

&lt;p&gt;The Lexer prototype is the prototype of the object returned by the &lt;code&gt;Lexer()&lt;/code&gt; function:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Lexer.prototype = {
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;appendSource&lt;/code&gt; is used to set/append source input:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  // Add input source.
  // The `chunk` object need to have the following properties:
  //
  //  .charCodeAt(N)   A function that return the Unicode character value at
  //                   position N, or a NaN if N is out of bounds.
  //
  //  .substring(A, B) A function that returns another chunk object that
  //                   represents the Unicode characters in the range [A,B)
  //
  appendSource: function (chunk) { ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;makeToken&lt;/code&gt; is mean to be used only internally by other Lexer functions. This is called every time a new token is being read:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  // Create a new token of `type` based on the internal source location state
  makeToken: function (type) { ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;flushToken&lt;/code&gt; is also meant as an internal function which is called each time a token is about to be returned as a result from the &lt;code&gt;next&lt;/code&gt; function:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  // Returns the current token and clears the &quot;reading token&quot; state. This is
  // an appropriate place to perform some post processing on tokens before
  // they are returned to the caller of `next()`. If `terminated_by_eos` is
  // true, the token was terminated by end of source.
  flushToken: function (terminated_by_eos) { ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;next&lt;/code&gt; is called to give control to the lexer and returns either when the lexer has read a token (a token is returned), when an error occurs (an exception is thrown) or the input source ended (null is returned).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  // Reads the next token. If `source_ended` is true, then no more source is
  // expected to arrive and thus EOS acts as a token terminator.
  next: function (source_ended) { ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That’s it for a summary of the Lexer design. I suggest you look through the code which is thoroughly documented.&lt;/p&gt;

&lt;p&gt;I’ve left one part unimplemented for you to write: Reading Text literals. Run the &lt;code&gt;lexer-demo.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ node lexer-demo.js
read_tokens(L)
L.next() -&amp;gt; SYMBOL &#39;Hello&#39; at 0:0
L.next() -&amp;gt; SYMBOL &#39;=&#39; at 0:6
...
Error: Lesson 1: Implement reading of Text tokens
;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Again, the source is available at &lt;a href=&quot;https://github.com/rsms/prog-lang-tutorial&quot;&gt;https://github.com/rsms/prog-lang-tutorial&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In the next article we will look at how semantic parsing fits into the evaluation pipeline.&lt;/p&gt;
</description>
        <pubDate>Sun, 07 Oct 2012 00:00:00 +0800</pubDate>
        <link>/languages/2012/10/07/mylang-tutorial1.html</link>
        <guid isPermaLink="true">/languages/2012/10/07/mylang-tutorial1.html</guid>
        
        <category>programming</category>
        
        
        <category>languages</category>
        
      </item>
    
  </channel>
</rss>
